import org.gradle.internal.os.OperatingSystem
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.regex.Pattern

/*
 * Distributed Cluster for Computer Vision
 * Copyright (C) 2024 Andrea Ingargiola, Bruno Esposito
 * andrea.ingargiola@studio.unibo.it
 * bruno.esposito@studio.unibo.it
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample C++ project to get you started.
 * For more details on building C++ applications and libraries, please refer to https://docs.gradle.org/8.7/userguide/building_cpp_projects.html in the Gradle documentation.
 */

plugins {
    id("com.github.jakemarsden.git-hooks") version "0.0.2"

    // Apply the cpp-application plugin to add support for building C++ executables
    `cpp-application`

    // Apply the cpp-unit-test plugin to add support for building and running C++ test executables
    `cpp-unit-test`
}

// Configurazione base del progetto
repositories {
    mavenCentral()
}

// Set the target operating system and architecture for this application
application {
    targetMachines.add(machines.linux.x86_64)
    targetMachines.add(machines.windows.x86_64)
}

unitTest {
    targetMachines.add(machines.linux.x86_64)
    targetMachines.add(machines.windows.x86_64)
}

val copyOpenCVLibs by tasks.registering(Copy::class) {
    onlyIf { OperatingSystem.current().isLinux }
    val libDir = file("build/libs")
    libDir.mkdirs()
    from("/usr/local/lib")
    into("build/libs")
    include("libopencv_*.so*")
}

val createDistribution by tasks.registering(Sync::class) {
    onlyIf { OperatingSystem.current().isLinux }
    from("build/exe/main/debug/linux") { into("bin") }
    from(tasks.named("copyOpenCVLibs")) { into("libs") }

    from("build/exe/main/debug/linux")
    from("build/libs")
    from("build/install/bin") { into("bin") }>
    from("run.sh")
    into("build/release/domain")
}

apply(from = "cpp-build-plugin.gradle.kts")

// Configura cpp-application per usare l'output di CMake
tasks.withType<LinkExecutable>().configureEach {
    onlyIf { OperatingSystem.current().isLinux }
    dependsOn(copyOpenCVLibs, createDistribution, "buildCMake")
    linkerArgs.addAll(listOf(
        "-L/usr/local/lib",
        "-lopencv_core",
        "-lopencv_imgproc",
        "-lopencv_objdetect",
        "-lopencv_highgui",
        "-lopencv_imgcodecs",
        "-lopencv_videoio",
        "-lopencv_calib3d",
        "-lopencv_features2d",
        "-lopencv_video"
    ))
    linkerArgs.add("-Wl,-rpath,/usr/local/lib")
    linkerArgs.add("-Wl,-rpath,\$ORIGIN/libs")
}

tasks.withType<CppCompile>().configureEach {
    dependsOn("buildCMake")
    onlyIf { OperatingSystem.current().isLinux }
    includes.from("/usr/local/include/opencv4")
}

/*
* Gradle tasks running docker image and container
* */
apply(from = "docker-build-plugin.gradle.kts")

tasks.test {
    onlyIf { OperatingSystem.current().isLinux }
    doLast {
        val runScript = project.projectDir
            .walk()
            .filter { it.isFile && it.name == "run.sh" }
            .elementAt(0)

        if (runScript.exists()) {
            var process: Process? = null
            var startTime = System.currentTimeMillis()
            var timeout = 30000 // 30 secondi

            try {
                exec {
                    commandLine("chmod", "+x", runScript.absolutePath)
                }

                process = ProcessBuilder("bash", runScript.absolutePath)
                    .redirectErrorStream(true)
                    .start()

                val reader = BufferedReader(InputStreamReader(process.inputStream))
                var line = reader.readLine()
                var found = false

                while (line != null && !found) {
                    println(line)

                    if (System.currentTimeMillis() - startTime > timeout) {
                        throw GradleException("Timeout waiting for server to start")
                    }

                    if (line.contains("Server started successfully")) {
                        found = true
                        Thread.sleep(2000)

                        val pid = process.pid()
                        exec {
                            commandLine("kill", "-SIGINT", "${pid}")
                            standardOutput = System.out
                            errorOutput = System.err
                        }
                        break
                    }
                    line = reader.readLine()
                }

                if (!found) {
                    throw GradleException("Server never started successfully")
                }

            } catch (e: Exception) {
                throw GradleException("Error running program: ${e.message}", e)
            } finally {
                if (process != null) {
                    process.destroy()
                    process.waitFor(5, TimeUnit.SECONDS)
                    if (process.isAlive()) {
                        process.destroyForcibly()
                    }
                }
            }
        } else {
            println("Script 'run.sh' not found.")
        }
    }
}

// Git Hooks configuration
gitHooks {
    setHooks(mapOf("pre-commit" to "spotlessApply check"))
    setHooks(mapOf("commit-msg" to "conventionalCommits"))
    setHooksDirectory(layout.projectDirectory.dir("../.git/hooks"))
}

// Conventional commits rules to add for commits checking
tasks.register("conventionalCommits") {
    val pattern = Pattern.compile("^(feat|fix|docs|style|refactor|test|chore|build|ci)(\\(.*\\))?: .{1,50}")
    val message = File(".git/COMMIT_EDITMSG").readText().trim()
    if (!pattern.matcher(message).find()) {
        throw GradleException("ERROR: Commit message does not follow Conventional Commits format.")
    }
}

// Git hooks installation through the build task
tasks.getByPath(":prepareKotlinBuildScriptModel").dependsOn.addAll(listOf(tasks.getByName("check")))